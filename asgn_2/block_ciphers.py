#! uv run
"""block_ciphers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_eyZQTY6t9bKq-5ChL6vDNUA3CA1Hfj-
"""

#Cell downloads the images


import requests
import os


# Create directory if needed
content_dir = os.path.join(os.getcwd(), "content")
os.makedirs(content_dir, exist_ok=True)


cp_logo_url = "https://cpslo.sharepoint.com/sites/Winter2026csc-321-09/Shared%20Documents/cp-logo.bmp?"

response = requests.get(cp_logo_url)
open(content_dir + "/cp-logo.bmp", "wb+").write(response.content)

mustang_logo_url = "https://cpslo.sharepoint.com/sites/Winter2026csc-321-09/Shared%20Documents/mustang.bmp?"

response = requests.get(mustang_logo_url)
open(content_dir + "/mustang.bmp", "wb+").write(response.content)


from Crypto.Cipher import AES
from Crypto.Hash import HMAC, SHA256
from Crypto.Random import get_random_bytes
from PIL import Image
import struct
import imghdr

'''
----- TASK 1 -----
In this task, you will explore the differences in
security attained by the ECB and CBC modes of encryption. Using the AES-128
primitive provided by your cryptographic library, implement your own versions of
ECB and CBC modes of encryption (do not use the built-in methods for modes of
operation).

Your program should:
1) take a (plaintext) file
2) generate a random key (and random IV, in the case of CBC)
3) write the encryption of the plaintext in a new file.

Output:
Encrypt one of the BMP files listed in this Canvas assignment using your ECB and
CBC implementations, creating two different ciphertexts. Be sure to the preserve
and re-append the plaintext BMP headers. The header size should be 54 bytes for
the BMP format we used, but we have also seen 138 bytes work for Apple Macs
when 54 bytes didnâ€™t

Additional Notes:
- use AES.new(key, AES.MODE_ECB). only encrypt 128 bits at a time
- need to implement your own key generation and PKCS padding
- to account for plaintexts that are not an integral size of AES's block size,
    implement PKCS#7 padding

'''


'''attempt to open .bmp file from /content'''
def getFileHeader(file_input):
  print("Requested file: " + file_input)
  try:
    #helpful link 1: https://stackoverflow.com/questions/47003833/how-to-read-bmp-file-header-in-python
    file_data = Image.open("/content/" + file_input)
    display(file_data)
    return file_data
    #print(imghdr.what(file_input))
    return 0
  except FileNotFoundError:
    print("File not found")
    return -1

def main():
  '''1) take a (plaintext) file'''
  file_input = input("Enter file name (either 'mustang.bmp' or 'cp-logo.bmp'):\n ")
  file_header = getFileHeader(file_input)

  '''2) generate a random key (and random IV, in the case of CBC)'''
  #helpful link 1: https://www.pycryptodome.org/src/examples#encrypt-data-with-aes
  #helpful link 2: https://pycryptodome.readthedocs.io/en/latest/src/cipher/classic.html#ecb-mode

if __name__ == "__main__":
    main()
