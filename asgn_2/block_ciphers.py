#! uv run
"""block_ciphers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_eyZQTY6t9bKq-5ChL6vDNUA3CA1Hfj-
"""

"""
----- TASK 1 -----
In this task, you will explore the differences in
security attained by the ECB and CBC modes of encryption. Using the AES-128
primitive provided by your cryptographic library, implement your own versions of
ECB and CBC modes of encryption (do not use the built-in methods for modes of
operation).

Your program should:
1) take a (plaintext) file
2) generate a random key (and random IV, in the case of CBC)
3) write the encryption of the plaintext in a new file.

Output:
Encrypt one of the BMP files listed in this Canvas assignment using your ECB and
CBC implementations, creating two different ciphertexts. Be sure to the preserve
and re-append the plaintext BMP headers. The header size should be 54 bytes for
the BMP format we used, but we have also seen 138 bytes work for Apple Macs
when 54 bytes didnâ€™t

Additional Notes:
- use AES.new(key, AES.MODE_ECB). only encrypt 128 bits at a time
- need to implement your own key generation and PKCS padding
- to account for plaintexts that are not an integral size of AES's block size,
    implement PKCS#7 padding

"""

import os
import struct
import time
from ast import Return
from mimetypes import encodings_map
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
import PIL
from Crypto.Cipher import AES
from Crypto.Hash import HMAC, SHA256
from Crypto.Random import get_random_bytes
from numpy._core import ndarray
from numpy._typing import NDArray
from PIL import Image
from PIL.ImageFile import ImageFile

content_dir = os.path.join(os.getcwd(), "content")
cp_logo_path = Path(content_dir + "/cp-logo.bmp")
mustang_logo_path = Path(content_dir + "/mustang.bmp")


def get_file(filename) -> ImageFile | None:
    """attempt to open .bmp file from /content"""
    print("Requested file: " + filename)
    try:
        # helpful link 1: https://stackoverflow.com/questions/47003833/how-to-read-bmp-file-header-in-python
        file_data = Image.open(content_dir + "/" + filename)
        return file_data
    except FileNotFoundError:
        print("File not found")
        return None


def show_img(image: ndarray, file_name):
    plt.title(file_name)
    plt.imshow(image)
    plt.axis("off")
    plt.show()


def get_header(filename: str) -> tuple:
    # helpful link: https://stackoverflow.com/questions/47003833/how-to-read-bmp-file-header-in-python
    with open(content_dir + "/" + filename, "rb") as f:
        raw_data = f.read()
    header_data = struct.unpack("<2sIHHIIIIHHIIIIII", raw_data[:54])
    return header_data


def get_body(image) -> ndarray:
    return np.asarray(image)


def encrypt_ecb(key: bytes, plaintext: bytes) -> bytes:
    cipher = AES.new(key, AES.MODE_ECB)
    padding_length = (16 - len(plaintext) % 16) % 16  # 0..15 is the range of this.

    # PKCS#7 padding: https://node-security.com/posts/cryptography-pkcs-7-padding/
    data_padded = plaintext + bytes([padding_length]) * padding_length

    bytes_under_cipher = bytes()
    for i in range(0, len(data_padded), 16):
        bytes_under_cipher += cipher.encrypt(data_padded[i : i + 16])

    # DEBUG: just let crypto do the magic here
    # bytes_under_cipher = cipher.encrypt(img_padded)

    encrypted_bytes = bytes_under_cipher[: len(plaintext)]

    return encrypted_bytes


def xor_bytes(a: bytes, b: bytes) -> bytes:
    out = bytes()
    for x, y in zip(a, b):
        out += bytes([(x ^ y)])

    return out


def encrypt_cbc(key: bytes, plaintext: bytes, IV: bytes, rounds: int = 1) -> bytes:
    cipher = AES.new(key, AES.MODE_ECB)

    for _ in range(rounds):
        padding_length = (16 - len(plaintext) % 16) % 16  # 0..15 is the range of this.

        # PKCS#7 padding: https://node-security.com/posts/cryptography-pkcs-7-padding/
        data_padded = plaintext + bytes([padding_length]) * padding_length

        bytes_under_cipher = bytes()
        prev_bytes = IV

        for i in range(0, len(data_padded), 16):
            chunk = data_padded[i : i + 16]
            chunk = xor_bytes(chunk, prev_bytes)
            chunk = cipher.encrypt(chunk)

            bytes_under_cipher += chunk
            prev_bytes = chunk

        # DEBUG: just let crypto do the magic here
        # bytes_under_cipher = cipher.encrypt(img_padded)

        encrypted_bytes = bytes_under_cipher[:]

        plaintext = encrypted_bytes

        # print(plaintext)

    return plaintext


def main():
    """1) take a (plaintext) file"""
    filename = input("Enter file name (either 'mustang.bmp' or 'cp-logo.bmp'): ")
    file_data = get_file(filename)
    # print(file_data)
    header_data = get_header(filename)
    # print(header_data)
    body_data = get_body(file_data)
    # print(body_data)

    img = body_data

    # for i in range(10):
    """2) generate a random key (and random IV, in the case of CBC)"""
    key = get_random_bytes(16)
    # print(body_data.tobytes())

    encrypted_bytes = encrypt_cbc(key, body_data.tobytes(), get_random_bytes(16))[
        : len(body_data.tobytes())
    ]

    # encrypted_bytes = encrypt_ecb(
    #     key,
    #     body_data.tobytes(),
    # )[: len(body_data.tobytes())]

    encrypted_img = np.frombuffer(encrypted_bytes, dtype=np.uint8).reshape(img.shape)
    show_img(encrypted_img, filename)

    if file_data is not None:
        file_data.close()

    # write the encryption of the plaintext in a new file
    fn = "encrypted.bmp"
    # open(fn, "wb")
    im = Image.fromarray(encrypted_img, "RGB")
    im.save(fn)

    # helpful link 1: https://www.pycryptodome.org/src/examples#encrypt-data-with-aes
    # helpful link 2: https://pycryptodome.readthedocs.io/en/latest/src/cipher/classic.html#ecb-mode


if __name__ == "__main__":
    main()
