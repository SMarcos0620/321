#! uv run
"""block_ciphers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_eyZQTY6t9bKq-5ChL6vDNUA3CA1Hfj-
"""

"""
----- TASK 1 -----
In this task, you will explore the differences in
security attained by the ECB and CBC modes of encryption. Using the AES-128
primitive provided by your cryptographic library, implement your own versions of
ECB and CBC modes of encryption (do not use the built-in methods for modes of
operation).

Your program should:
1) take a (plaintext) file
2) generate a random key (and random IV, in the case of CBC)
3) write the encryption of the plaintext in a new file.

Output:
Encrypt one of the BMP files listed in this Canvas assignment using your ECB and
CBC implementations, creating two different ciphertexts. Be sure to the preserve
and re-append the plaintext BMP headers. The header size should be 54 bytes for
the BMP format we used, but we have also seen 138 bytes work for Apple Macs
when 54 bytes didnâ€™t

Additional Notes:
- use AES.new(key, AES.MODE_ECB). only encrypt 128 bits at a time
- need to implement your own key generation and PKCS padding
- to account for plaintexts that are not an integral size of AES's block size,
    implement PKCS#7 padding

"""

import os
import struct
import time
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
from Crypto.Cipher import AES
from Crypto.Hash import HMAC, SHA256
from Crypto.Random import get_random_bytes
from numpy._core import ndarray
from numpy._typing import NDArray
from PIL import Image

content_dir = os.path.join(os.getcwd(), "content")
cp_logo_path = Path(content_dir + "/cp-logo.bmp")
mustang_logo_path = Path(content_dir + "/mustang.bmp")

"""attempt to open .bmp file from /content"""


def getFile(file_input):
    print("Requested file: " + file_input)
    try:
        # helpful link 1: https://stackoverflow.com/questions/47003833/how-to-read-bmp-file-header-in-python
        file_data = Image.open(content_dir + "/" + file_input)
        return file_data
    except FileNotFoundError:
        print("File not found")
        return -1


def showImg(image):
    plt.imshow(image)
    plt.axis("off")
    plt.show()
    return


def getHeader(file_input):
    # helpful link: https://stackoverflow.com/questions/47003833/how-to-read-bmp-file-header-in-python
    with open(content_dir + "/" + file_input, "rb") as f:
        raw_data = f.read()
    header_data = struct.unpack("<2sIHHIIIIHHIIIIII", raw_data[:54])
    return header_data


def getBody(image):
    return np.asarray(image)


def main():
    """1) take a (plaintext) file"""
    file_input = input("Enter file name (either 'mustang.bmp' or 'cp-logo.bmp'): ")
    file_data = getFile(file_input)
    # print(file_data)
    header_data = getHeader(file_input)
    # print(header_data)
    body_data = getBody(file_data)
    # print(body_data)

    """2) generate a random key (and random IV, in the case of CBC)"""
    aes_key = get_random_bytes(16)
    cipher = AES.new(aes_key, AES.MODE_ECB)

    # print(cipher)

    # body_dims = body_data.shape

    padding_length = (16 - len(body_data) % 16) % 16

    img_padded = body_data.tobytes() + bytes([padding_length]) * padding_length

    bytes_under_cipher = cipher.encrypt(img_padded)

    encrypted_image_bytes = bytes_under_cipher[: len(body_data.tobytes())]

    encrypted_img = np.frombuffer(encrypted_image_bytes, dtype=np.uint8).reshape(
        body_data.shape
    )

    showImg(encrypted_img)

    # helpful link 1: https://www.pycryptodome.org/src/examples#encrypt-data-with-aes
    # helpful link 2: https://pycryptodome.readthedocs.io/en/latest/src/cipher/classic.html#ecb-mode


if __name__ == "__main__":
    main()
